{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import math\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "\n",
    "from qiskit import QuantumCircuit\n",
    "import qiskit.quantum_info as qi\n",
    "\n",
    "\n",
    "from hamming import *\n",
    "from loss import *"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(6, 8)\n"
     ]
    }
   ],
   "source": [
    "N_xi, N_features = 6, 8\n",
    "xi = np.random.randint(2, size=(N_xi, N_features))\n",
    "xi[ xi == 0 ] = -1   # data is encoded as +- 1\n",
    "\n",
    "labels = np.ones((N_features, ))\n",
    "\n",
    "print(xi.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<qiskit.circuit.instructionset.InstructionSet at 0x7fec773e84c0>"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "HH = Hamming(n_qubit = 8, n_ancillary = 4, dataset = xi)\n",
    "\n",
    "qc = QuantumCircuit( HH.n_qubit + HH.n_ancillary )\n",
    "\n",
    "# init the circuit state\n",
    "for ii in range(HH.n_qubit):  qc.h(ii)\n",
    "\n",
    "qc.x(8+3)\n",
    "\n",
    "#qc.barrier()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<pre style=\"word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: &quot;Courier New&quot;,Courier,monospace\">      ┌───┐\n",
       " q_0: ┤ H ├\n",
       "      ├───┤\n",
       " q_1: ┤ H ├\n",
       "      ├───┤\n",
       " q_2: ┤ H ├\n",
       "      ├───┤\n",
       " q_3: ┤ H ├\n",
       "      ├───┤\n",
       " q_4: ┤ H ├\n",
       "      ├───┤\n",
       " q_5: ┤ H ├\n",
       "      ├───┤\n",
       " q_6: ┤ H ├\n",
       "      ├───┤\n",
       " q_7: ┤ H ├\n",
       "      └───┘\n",
       " q_8: ─────\n",
       "           \n",
       " q_9: ─────\n",
       "           \n",
       "q_10: ─────\n",
       "      ┌───┐\n",
       "q_11: ┤ X ├\n",
       "      └───┘</pre>"
      ],
      "text/plain": [
       "      ┌───┐\n",
       " q_0: ┤ H ├\n",
       "      ├───┤\n",
       " q_1: ┤ H ├\n",
       "      ├───┤\n",
       " q_2: ┤ H ├\n",
       "      ├───┤\n",
       " q_3: ┤ H ├\n",
       "      ├───┤\n",
       " q_4: ┤ H ├\n",
       "      ├───┤\n",
       " q_5: ┤ H ├\n",
       "      ├───┤\n",
       " q_6: ┤ H ├\n",
       "      ├───┤\n",
       " q_7: ┤ H ├\n",
       "      └───┘\n",
       " q_8: ─────\n",
       "           \n",
       " q_9: ─────\n",
       "           \n",
       "q_10: ─────\n",
       "      ┌───┐\n",
       "q_11: ┤ X ├\n",
       "      └───┘"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "qc.draw()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Constructing H_perc: 100%|██████████| 6/6 [00:00<00:00, 252.62it/s]\n"
     ]
    }
   ],
   "source": [
    "P = 100\n",
    "dt = 1\n",
    "\n",
    "for pp in range(100):\n",
    "    s_p = (pp+1)/P\n",
    "    gamma_p = s_p*dt\n",
    "    beta_p = (1-s_p)*dt\n",
    "\n",
    "    for mu in range( HH.data_size ):\n",
    "        #qc = HH.hamming_circuit_for_sample(mu, qc = qc)\n",
    "        #HH.control_unitaries(mu, gamma = gamma_p, qc = qc) # FIXME\n",
    "        for jj in range( HH.n_qubit ):\n",
    "            #qc.rz(-2*gamma_p*HH.dataset[mu, jj]/np.sqrt(HH.n_qubit), jj)\n",
    "            #qc.cp(-2*gamma_p*HH.dataset[mu, jj]/np.sqrt(HH.n_qubit), jj, 11)\n",
    "            qc.cu(0, 2*gamma_p*HH.dataset[mu, jj]/np.sqrt(HH.n_qubit), 0, gamma_p*HH.dataset[mu, jj]/np.sqrt(HH.n_qubit), 11, jj)\n",
    "\n",
    "\n",
    "    # apply Ux\n",
    "    for ii in range( HH.n_qubit ):\n",
    "    #    # syntax:  lambda, control_qubit, target_qubit\n",
    "        qc.u( 2 * beta_p, math.pi/2, -math.pi/2, ii)\n",
    "\n",
    "    # measure loss\n",
    "    get_statevec(qc, HH.n_qubit)\n",
    "\n",
    "\n",
    "simulator = Aer.get_backend('aer_simulator_statevector')\n",
    "circ = transpile(qc, simulator) \n",
    "\n",
    "# Run and get counts\n",
    "result = simulator.run(circ).result()\n",
    "res = get_losses_from_results(result, xi, labels, HH.n_qubit, representation='buuuh')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/home/baronefr/.local/lib/python3.10/site-packages/matplotlib/cbook/__init__.py:1369: ComplexWarning: Casting complex values to real discards the imaginary part\n",
      "  return np.asarray(x, float)\n",
      "/tmp/ipykernel_11664/2389795877.py:2: UserWarning: Data has no positive values, and therefore cannot be log-scaled.\n",
      "  plt.yscale('log')\n"
     ]
    },
    {
     "data": {
      "image/png": "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4gQASEWcAACpiBMAIBVxAgCkIk4AgFTECQCQijgBAFIRJwBAKuIEAEhFnAAAqYgTACAVcQIApCJOAIBUxAkAkIo4AQBSEScAQCriBABIRZwAAKmIEwAgFXECAKQiTgCAVMQJAJCKOAEAUhEnAEAq4gQASEWcAACp1CVO7rzzznjve98bxx13XPzkJz+pxwgAQFLjDvUDvvbaa9HZ2Rn33XdfVCqVWLBgQSxfvjymTZt2qEcBABI65K+cbNiwIU444YSYOXNmTJo0KZYtWxa///3vD/UYAEBSQ46TBx54IM4+++xoaWmJhoaGWLt27RuuqVarMXfu3JgwYUIsXrw4NmzY0H9ux44dMXPmzP77M2fOjO3btx/Y9ADAqDPkONm7d2/Mnz8/qtXqm56/9dZbo7OzM6688sp45JFHYv78+bF06dLYuXPnAQ346quvRq1WG3ADAEavIcfJsmXL4qqrrorly5e/6flrr702zj///Fi5cmW0trbG9ddfHxMnTowbbrghIiJaWloGvFKyffv2aGlpecvHW7NmTVQqlf7b7NmzhzoyADCCDOtnTvbt2xebNm2K9vb2/32AMWOivb091q1bFxERixYtii1btsT27dtjz549cdddd8XSpUvf8mdeeuml0dvb23/btm3bcI4MACQzrN/WefHFF2P//v3R3Nw84Hhzc3M88cQT/3nAcePiu9/9bpx++unR19cXF1988dt+U6exsTEaGxuHc0wAILFD/lXiiIhzzjknzjnnnHo8NACQ3LC+rTN9+vQYO3Zs9PT0DDje09MTM2bMGM6HAgBGqWGNk/Hjx8eCBQuiq6ur/1hfX190dXXFkiVLhvOhAIBRashv6+zZsyeeeeaZ/vtbt26NzZs3x9SpU2POnDnR2dkZHR0dsXDhwli0aFFcd911sXfv3li5cuWwDg4AjE5DjpONGzfG6aef3n+/s7MzIiI6OjripptuinPPPTdeeOGFuOKKK6K7uztOPvnkuPvuu9/wIVkAgDfTUEop9R5iKGq1WlQqlejt7Y2mpqZ6jwMADMJQnr/r8leJAQDeijgBAFIRJwBAKuIEAEhFnAAAqYgTACAVcQIApFKXP/x3IKrValSr1Xjttdci4j/flwYARob/Pm8P5terjbhfwvaPf/wjZs+eXe8xAIADsG3btpg1a9bbXjPi4qSvry927NgRkydPjoaGhmH92bVaLWbPnh3btm3z22cPMrs+dOz60LHrQ8euD53h2nUpJXbv3h0tLS0xZszbf6pkxLyt819jxoz5/xbXO9XU1OT/7IeIXR86dn3o2PWhY9eHznDsulKpDOo6H4gFAFIRJwBAKuLkdRobG+PKK6+MxsbGeo8y6tn1oWPXh45dHzp2fejUY9cj7gOxAMDo5pUTACAVcQIApCJOAIBUxAkAkIo4+X+q1WrMnTs3JkyYEIsXL44NGzbUe6QRb82aNdHW1haTJ0+Oo48+Oj7+8Y/Hk08+OeCaf/3rX7Fq1aqYNm1aTJo0KT75yU9GT09PnSYePa655ppoaGiIiy66qP+YXQ+f7du3x2c/+9mYNm1aHHnkkXHSSSfFxo0b+8+XUuKKK66IY445Jo488shob2+Pp59+uo4Tj0z79++Pyy+/PObNmxdHHnlkvPvd745vfetbA/42i10fmAceeCDOPvvsaGlpiYaGhli7du2A84PZ60svvRQrVqyIpqammDJlSnzxi1+MPXv2DM+AhXLLLbeU8ePHlxtuuKH89a9/Leeff36ZMmVK6enpqfdoI9rSpUvLjTfeWLZs2VI2b95cPvrRj5Y5c+aUPXv29F9zwQUXlNmzZ5eurq6ycePG8sEPfrCceuqpdZx65NuwYUOZO3duef/7319Wr17df9yuh8dLL71Ujj322PL5z3++rF+/vjz77LPld7/7XXnmmWf6r7nmmmtKpVIpa9euLY899lg555xzyrx588orr7xSx8lHnquvvrpMmzat3HnnnWXr1q3ltttuK5MmTSrf+973+q+x6wPz29/+tlx22WXl9ttvLxFR7rjjjgHnB7PXM888s8yfP7889NBD5U9/+lN5z3veU84777xhmU+clFIWLVpUVq1a1X9///79paWlpaxZs6aOU40+O3fuLBFR7r///lJKKbt27SpHHHFEue222/qv+dvf/lYioqxbt65eY45ou3fvLscdd1y55557yoc//OH+OLHr4fONb3yjfOhDH3rL8319fWXGjBnlO9/5Tv+xXbt2lcbGxvKLX/ziUIw4apx11lnlC1/4woBjn/jEJ8qKFStKKXY9XP5vnAxmr48//niJiPLwww/3X3PXXXeVhoaGsn379nc802H/ts6+ffti06ZN0d7e3n9szJgx0d7eHuvWravjZKNPb29vRERMnTo1IiI2bdoU//73vwfs/vjjj485c+bY/QFatWpVnHXWWQN2GmHXw+nXv/51LFy4MD796U/H0UcfHaecckr8+Mc/7j+/devW6O7uHrDrSqUSixcvtushOvXUU6OrqyueeuqpiIh47LHH4sEHH4xly5ZFhF0fLIPZ67p162LKlCmxcOHC/mva29tjzJgxsX79+nc8w4j7w3/D7cUXX4z9+/dHc3PzgOPNzc3xxBNP1Gmq0aevry8uuuiiOO200+LEE0+MiIju7u4YP358TJkyZcC1zc3N0d3dXYcpR7ZbbrklHnnkkXj44YffcM6uh8+zzz4bP/zhD6OzszO++c1vxsMPPxxf/epXY/z48dHR0dG/zzf7N8Wuh+aSSy6JWq0Wxx9/fIwdOzb2798fV199daxYsSIiwq4PksHstbu7O44++ugB58eNGxdTp04dlt0f9nHCobFq1arYsmVLPPjgg/UeZVTatm1brF69Ou65556YMGFCvccZ1fr6+mLhwoXx7W9/OyIiTjnllNiyZUtcf/310dHRUefpRpdf/vKXcfPNN8fPf/7zOOGEE2Lz5s1x0UUXRUtLi12Pcof92zrTp0+PsWPHvuFbCz09PTFjxow6TTW6XHjhhXHnnXfGfffdF7Nmzeo/PmPGjNi3b1/s2rVrwPV2P3SbNm2KnTt3xgc+8IEYN25cjBs3Lu6///74/ve/H+PGjYvm5ma7HibHHHNMtLa2Djj2vve9L5577rmIiP59+jflnfv6178el1xySXzmM5+Jk046KT73uc/F1772tVizZk1E2PXBMpi9zpgxI3bu3Dng/GuvvRYvvfTSsOz+sI+T8ePHx4IFC6Krq6v/WF9fX3R1dcWSJUvqONnIV0qJCy+8MO6444649957Y968eQPOL1iwII444ogBu3/yySfjueees/shOuOMM+Ivf/lLbN68uf+2cOHCWLFiRf//tuvhcdppp73hK/FPPfVUHHvssRERMW/evJgxY8aAXddqtVi/fr1dD9HLL78cY8YMfJoaO3Zs9PX1RYRdHyyD2euSJUti165dsWnTpv5r7r333ujr64vFixe/8yHe8UdqR4FbbrmlNDY2lptuuqk8/vjj5Utf+lKZMmVK6e7urvdoI9qXv/zlUqlUyh//+Mfy/PPP999efvnl/msuuOCCMmfOnHLvvfeWjRs3liVLlpQlS5bUcerR4/Xf1inFrofLhg0byrhx48rVV19dnn766XLzzTeXiRMnlp/97Gf911xzzTVlypQp5Ve/+lX585//XD72sY/5eusB6OjoKDNnzuz/KvHtt99epk+fXi6++OL+a+z6wOzevbs8+uij5dFHHy0RUa699try6KOPlr///e+llMHt9cwzzyynnHJKWb9+fXnwwQfLcccd56vEw+0HP/hBmTNnThk/fnxZtGhReeihh+o90ogXEW96u/HGG/uveeWVV8pXvvKVctRRR5WJEyeW5cuXl+eff75+Q48i/zdO7Hr4/OY3vyknnnhiaWxsLMcff3z50Y9+NOB8X19fufzyy0tzc3NpbGwsZ5xxRnnyySfrNO3IVavVyurVq8ucOXPKhAkTyrve9a5y2WWXlVdffbX/Grs+MPfdd9+b/vvc0dFRShncXv/5z3+W8847r0yaNKk0NTWVlStXlt27dw/LfA2lvO5X7QEA1Nlh/5kTACAXcQIApCJOAIBUxAkAkIo4AQBSEScAQCriBABIRZwAAKmIEwAgFXECAKQiTgCAVMQJAJDK/wCpP/1jO4D/hQAAAABJRU5ErkJggg==",
      "text/plain": [
       "<Figure size 640x480 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.plot(res)\n",
    "plt.yscale('log')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n",
       "       0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n",
       "       0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n",
       "       0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n",
       "       0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n",
       "       0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n",
       "       0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n",
       "       0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n",
       "       0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n",
       "       0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n",
       "       0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n",
       "       0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n",
       "       0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j])"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "res"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "#qc.draw()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.6"
  },
  "orig_nbformat": 4
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
